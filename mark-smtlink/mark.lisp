(in-package "ACL2")
(include-book "global")

;; Add below code as in this place.
;; This is defining a world where arithmetic is loaded.
;; I need this because later I need a world without
;; 
(deftheory before-arith (current-theory :here))
(include-book "arithmetic/top-with-meta" :dir :system)
(deftheory after-arith (current-theory :here))

(deftheory arithmetic-book-only (set-difference-theories (theory 'after-arith) (theory 'before-arith)))
;; end

(ld "SMT-connect.lisp")
(logic)
:set-state-ok t
:set-ignore-ok t

(defun fdco (n v0 dv g1)
  (/ (* (mu) (+ 1 (* *alpha* (+ v0 dv)))) (+ 1 (* *beta* n g1))))

(defun B-term-expt (h)
  (expt (gamma) (- h)))

(defun B-term-rest (h v0 dv g1)
  (- (* (mu) (/ (+ 1 (* *alpha* (+ v0 dv))) (+ 1 (* *beta* (+ (* h g1) (equ-c v0)))))) 1))

(defun B-term (h v0 dv g1)
  (* (B-term-expt h) (B-term-rest h v0 dv g1)))

(defun B-sum (h_lo h_hi v0 dv g1)
  (declare (xargs :measure (if (or (not (integerp h_hi)) (not (integerp h_lo)) (< h_hi h_lo))
			       0
			       (1+ (- h_hi h_lo)))))
  (if (or (not (integerp h_hi)) (not (integerp h_lo)) (> h_lo h_hi))  0
      (+ (B-term h_hi v0 dv g1) (B-term (- h_hi) v0 dv g1) (B-sum h_lo (- h_hi 1) v0 dv g1))))

(defun B-expt (n)
  (expt (gamma) (- n 2)))

(defun B (n v0 dv g1)
  (* (B-expt n)
     (B-sum 1 (- n 2) v0 dv g1)))

(encapsulate ()

(local (in-theory (disable arithmetic-book-only)))

(local
(include-book "arithmetic-5/top" :dir :system)
)

(defthm B-term-neg-mrg1-lemma1
  (implies (AND (< (+ (- (* 1/5 (/ (EXPT 5 H))))
                    (* 5 (EXPT 5 H)
                       (+ 1 DV V0)
                       (/ (+ 1 G1 V0 (* G1 H))))
                    (* 1/5 (/ (EXPT 5 H))
                       (+ 1 DV V0)
                       (/ (+ 1 (- G1) V0 (- (* G1 H))))))
                 (* 5 (EXPT 5 H)))
              (INTEGERP H)
              (RATIONALP V0)
              (RATIONALP DV)
              (RATIONALP G1)
              (< 0 V0)
              (< 0 DV)
              (< 0 G1)
              (<= 1 H)
              (< H (+ -5/4 (/ G1) (* (/ G1) V0)))
              (< (+ (- (* (EXPT 5 H)
                          (EXPT 5 H)))
                    (* (+ 1 DV V0)
                       (/ (+ 1 V0 (- (* G1 H)))))
                    (* (EXPT 5 H)
                       (EXPT 5 H)
                       (+ 1 DV V0)
                       (/ (+ 1 V0 (* G1 H)))))
                 1))
         (< (+ (- (* 5 (EXPT 5 H)
                     (* 5 (EXPT 5 H))))
               (* (+ 1 DV V0)
                  (/ (+ 1 (- G1) V0 (- (* G1 H)))))
               (* 5 (EXPT 5 H)
                  (* 5 (EXPT 5 H))
                  (+ 1 DV V0)
                  (/ (+ 1 G1 V0 (* G1 H)))))
            1))
  :rule-classes nil)
)

(skip-proofs
(defthm stupid-lemma
  (implies (and (integerp a) (> a 0))
	   (equal (denominator (/ a)) a))
  :rule-classes nil)
)

(defthm B-term-neg-mrg1-lemma2-lemma1
  (equal (* 1/5 (/ (EXPT 5 H)))
	 (/ (* 5 (expt 5 h))))
  :rule-classes nil)

(defthm B-term-neg-mrg1-lemma2-lemma2
  (equal
   (IMPLIES (AND (< (+ (- (* 1/5 (/ (EXPT 5 H))))
                    (* 5 (EXPT 5 H)
                       (+ 1 DV V0)
                       (/ (+ 1 G1 V0 (* G1 H))))
                    (* 1/5 (/ (EXPT 5 H))
                       (+ 1 DV V0)
                       (/ (+ 1 (- G1) V0 (- (* G1 H))))))
                 (* 5 (EXPT 5 H)))
              (INTEGERP H)
              (RATIONALP V0)
              (RATIONALP DV)
              (RATIONALP G1)
              (< 0 V0)
              (< 0 DV)
              (< 0 G1)
              (<= 1 H)
              (< H (+ -5/4 (/ G1) (* (/ G1) V0)))
              (< (+ (- (* (EXPT 5 H)
                          (DENOMINATOR (/ (EXPT 5 H)))))
                    (* (+ 1 DV V0)
                       (/ (+ 1 V0 (- (* G1 H)))))
                    (* (EXPT 5 H)
                       (DENOMINATOR (/ (EXPT 5 H)))
                       (+ 1 DV V0)
                       (/ (+ 1 V0 (* G1 H)))))
                 1))
         (< (+ (- (* 5 (EXPT 5 H)
                     (DENOMINATOR (* 1/5 (/ (EXPT 5 H))))))
               (* (+ 1 DV V0)
                  (/ (+ 1 (- G1) V0 (- (* G1 H)))))
               (* 5 (EXPT 5 H)
                  (DENOMINATOR (* 1/5 (/ (EXPT 5 H))))
                  (+ 1 DV V0)
                  (/ (+ 1 G1 V0 (* G1 H)))))
            1))
   (IMPLIES (AND (< (+ (- (* 1/5 (/ (EXPT 5 H))))
                    (* 5 (EXPT 5 H)
                       (+ 1 DV V0)
                       (/ (+ 1 G1 V0 (* G1 H))))
                    (* 1/5 (/ (EXPT 5 H))
                       (+ 1 DV V0)
                       (/ (+ 1 (- G1) V0 (- (* G1 H))))))
                 (* 5 (EXPT 5 H)))
              (INTEGERP H)
              (RATIONALP V0)
              (RATIONALP DV)
              (RATIONALP G1)
              (< 0 V0)
              (< 0 DV)
              (< 0 G1)
              (<= 1 H)
              (< H (+ -5/4 (/ G1) (* (/ G1) V0)))
              (< (+ (- (* (EXPT 5 H)
                          (DENOMINATOR (/ (EXPT 5 H)))))
                    (* (+ 1 DV V0)
                       (/ (+ 1 V0 (- (* G1 H)))))
                    (* (EXPT 5 H)
                       (DENOMINATOR (/ (EXPT 5 H)))
                       (+ 1 DV V0)
                       (/ (+ 1 V0 (* G1 H)))))
                 1))
         (< (+ (- (* 5 (EXPT 5 H)
                     (DENOMINATOR (/ (* 5 (EXPT 5 H))))))
               (* (+ 1 DV V0)
                  (/ (+ 1 (- G1) V0 (- (* G1 H)))))
               (* 5 (EXPT 5 H)
                  (DENOMINATOR (/ (* 5 (EXPT 5 H))))
                  (+ 1 DV V0)
                  (/ (+ 1 G1 V0 (* G1 H)))))
            1)))
  )

(defthm B-term-neg-mrg1-lemma2-lemma3
  (equal
   (IMPLIES (AND (< (+ (- (* 1/5 (/ (EXPT 5 H))))
                    (* 5 (EXPT 5 H)
                       (+ 1 DV V0)
                       (/ (+ 1 G1 V0 (* G1 H))))
                    (* 1/5 (/ (EXPT 5 H))
                       (+ 1 DV V0)
                       (/ (+ 1 (- G1) V0 (- (* G1 H))))))
                 (* 5 (EXPT 5 H)))
              (INTEGERP H)
              (RATIONALP V0)
              (RATIONALP DV)
              (RATIONALP G1)
              (< 0 V0)
              (< 0 DV)
              (< 0 G1)
              (<= 1 H)
              (< H (+ -5/4 (/ G1) (* (/ G1) V0)))
              (< (+ (- (* (EXPT 5 H)
                          (DENOMINATOR (/ (EXPT 5 H)))))
                    (* (+ 1 DV V0)
                       (/ (+ 1 V0 (- (* G1 H)))))
                    (* (EXPT 5 H)
                       (DENOMINATOR (/ (EXPT 5 H)))
                       (+ 1 DV V0)
                       (/ (+ 1 V0 (* G1 H)))))
                 1))
         (< (+ (- (* 5 (EXPT 5 H)
                     (DENOMINATOR (/ (* 5 (EXPT 5 H))))))
               (* (+ 1 DV V0)
                  (/ (+ 1 (- G1) V0 (- (* G1 H)))))
               (* 5 (EXPT 5 H)
                  (DENOMINATOR (/ (* 5 (EXPT 5 H))))
                  (+ 1 DV V0)
                  (/ (+ 1 G1 V0 (* G1 H)))))
            1))
   (implies (AND (< (+ (- (* 1/5 (/ (EXPT 5 H))))
                    (* 5 (EXPT 5 H)
                       (+ 1 DV V0)
                       (/ (+ 1 G1 V0 (* G1 H))))
                    (* 1/5 (/ (EXPT 5 H))
                       (+ 1 DV V0)
                       (/ (+ 1 (- G1) V0 (- (* G1 H))))))
                 (* 5 (EXPT 5 H)))
              (INTEGERP H)
              (RATIONALP V0)
              (RATIONALP DV)
              (RATIONALP G1)
              (< 0 V0)
              (< 0 DV)
              (< 0 G1)
              (<= 1 H)
              (< H (+ -5/4 (/ G1) (* (/ G1) V0)))
              (< (+ (- (* (EXPT 5 H)
                          (EXPT 5 H)))
                    (* (+ 1 DV V0)
                       (/ (+ 1 V0 (- (* G1 H)))))
                    (* (EXPT 5 H)
                       (EXPT 5 H)
                       (+ 1 DV V0)
                       (/ (+ 1 V0 (* G1 H)))))
                 1))
         (< (+ (- (* 5 (EXPT 5 H)
                     (* 5 (EXPT 5 H))))
               (* (+ 1 DV V0)
                  (/ (+ 1 (- G1) V0 (- (* G1 H)))))
               (* 5 (EXPT 5 H)
                  (* 5 (EXPT 5 H))
                  (+ 1 DV V0)
                  (/ (+ 1 G1 V0 (* G1 H)))))
            1))
   )
  :hints (("Goal"
	   :use ((:instance stupid-lemma (a (expt 5 h)))
		 (:instance stupid-lemma (a (* 5 (expt 5 h)))))))
  )

(defthm B-term-neg-mrg1-lemma2
    (IMPLIES (AND (< (+ (- (* 1/5 (/ (EXPT 5 H))))
                    (* 5 (EXPT 5 H)
                       (+ 1 DV V0)
                       (/ (+ 1 G1 V0 (* G1 H))))
                    (* 1/5 (/ (EXPT 5 H))
                       (+ 1 DV V0)
                       (/ (+ 1 (- G1) V0 (- (* G1 H))))))
                 (* 5 (EXPT 5 H)))
              (INTEGERP H)
              (RATIONALP V0)
              (RATIONALP DV)
              (RATIONALP G1)
              (< 0 V0)
              (< 0 DV)
              (< 0 G1)
              (<= 1 H)
              (< H (+ -5/4 (/ G1) (* (/ G1) V0)))
              (< (+ (- (* (EXPT 5 H)
                          (DENOMINATOR (/ (EXPT 5 H)))))
                    (* (+ 1 DV V0)
                       (/ (+ 1 V0 (- (* G1 H)))))
                    (* (EXPT 5 H)
                       (DENOMINATOR (/ (EXPT 5 H)))
                       (+ 1 DV V0)
                       (/ (+ 1 V0 (* G1 H)))))
                 1))
         (< (+ (- (* 5 (EXPT 5 H)
                     (DENOMINATOR (* 1/5 (/ (EXPT 5 H))))))
               (* (+ 1 DV V0)
                  (/ (+ 1 (- G1) V0 (- (* G1 H)))))
               (* 5 (EXPT 5 H)
                  (DENOMINATOR (* 1/5 (/ (EXPT 5 H))))
                  (+ 1 DV V0)
                  (/ (+ 1 G1 V0 (* G1 H)))))
            1))
  :hints (("Goal"
	   :do-not '(simplify)
	   :use ((:instance B-term-neg-mrg1-lemma2-lemma3)
		 (:instance B-term-neg-mrg1-lemma1)
		 ))))

(defthm B-term-neg-mrg1
  (implies (and (and (integerp h)
		     (rationalp v0)
		     (rationalp dv)
		     (rationalp g1))
		(and (< 0 v0)
		     (< 0 dv)
		     (< 0 g1)
		     (>= h 1)
		     (< h (- (/ (1+ (* *beta* (equ-c v0))) (* g1 *beta*)) (/ (- 1 (gamma)))))
		     (< (+ (B-term h v0 dv g1) (B-term (- h) v0 dv g1)) 0)))
	   (< (+ (B-term (1+ h) v0 dv g1) (B-term (- (1+ h)) v0 dv g1)) 0))
  :hints
  (("Goal"
    :clause-processor
    (my-clause-processor clause
			 '( (:expand ((:functions ((B-term rationalp)
						  (B-term-expt rationalp)
						  (B-term-rest rationalp)
						  (gamma rationalp)
						  (mu rationalp)
						  (equ-c rationalp)
						  (dv0 rationalp)))
				      (:expansion-level 1)))
			   (:python-file "B-term-neg-mrg1") ;;mktemp
			   (:let ())
			   (:hypothesize ())
			   (:use ((:type ())
				  (:hypo ())
				  (:main ()))))
			 state))))
