1. SMT-function and SMT-translator have termination problem
2. how to arrage the files, include and certify books?

;; ====================================================
When replacing part of the formula with the let expression,
there are several places the replacement can occur:
before the expansion, while the expansion and after the
expassion.

After the expansion make sense because functions defined
by user can have terms that requires user simplification.
And before the expansion also kind of make sense because
it guides ACL2 to prove some given properties first and
then this result may help prove the theorem. During the
expansion may make sense too, and it can be cool, but we
are just not so sure how to control that kind of rewriting.
It can be convenient that part of the expansion is
rewritten and part of it is not, and this is a better way
to guide ACL2.

So temporarily, we'll rewrite the formula before and after
the expansion. No other time.

;; ===================================================

I'm not supporting recognizing lambda expression for let
expressions. The reason is that, it's kind of weird that
the user would think about what the expansion is like and
take something spanning two function expansions as some
hint hypothesis. It could be possible, but weird. And the
implementation can be really tough. I can ask Mark this
question tomorrow.

-- actually, I think I can solve the problem by expanding
   the let-expression's functions. ... tomorrow ... nope..
   this is not a problem...


05/13
do we want type for hypothesis variables?
helper.lisp : append-and-decl and append-and-hyp needs to
combine. Need type information

variable names in lisp, if has dashes, won't work in z3!!!!

When giving new hypotheses, the format is not in the underneath
form. I don't really want to user to figure out the form.
How to do that?

05/15
I need to solve above three problems today!

05/16
(let (...) clause) -- not working
I tried it in the command, cannot prove......
done!

05/17
(let (...) clause) -- done
new hypotheses -- done
variable name? -- ??
type inference? -- done

<<<<<<< HEAD
Function expansion todo list:
1. variable creation, can it be a symbol not a string? -- probably fixed
2. 
3. translating let expression into? what to do in Z3?
4. wrap up the function expansion code into the clause processor
5. try!


=============================================================
Hi Yan,
> I find that let expressions will be transformed to a
lambda expression.
Ah, that makes lots of sense.

> Should I expand the function definitions instead
into a lambda expression?

That sounds like a great idea
(i.e. I feel stupid that I suggested the other way).

Let's see, if you have
  (defun f (x y) (+ (* x x) (* x y) (* y y)))

and later have an expression
  (> (f (+ (* 2 a) b) (- c d)) 0)

then your translator could produce
  smt_gt((lambda v1, v2: smt_plus(smt_times(v1, v1), smt_times(v1, v2), smt_times(v2, v2)))(smt_plus(smt_times(smt_ratnum(2), v("a")), v("b")),smt_minus(v("c"), v("d"))),smt_ratnum(0))

But wait, we don't need to do the lookup to get v1 and v2, they are python variables.  In fact, they *must* be python variables.  So, do we still want the v(name) function?  Or, could you use python variables like you orginally wanted?  You could probably just use python variables.  Note that you'll need to give them a special prefix to make sure that they don't match the names of anything in your code.  v_name should be fine (just don't use v_ as the start of the name of anything in your code).

Now we might have:
(defthm thm1
  (implies
    (and (rationalp a)
         (rationalp b)
	 (rationalp c)
	 (rationalp d))
    (implies (neq c d) (> (f (+ (* 2 a) b) (- c d))))))
And the translation to python would be
  v_a = smt_real("a")
  v_b = smt_real("b")
  v_c = smt_real("c")
  v_d = smt_real("d")						claim = smt_implies(smt_neq(v_c, v_d),smt_gt((lambda v_1, v_2: smt_plus(smt_times(v_1, v_1), smt_times(v_1, v_2), smt_times(v_2, v_2)))(smt_plus(smt_times(smt_ratnum(2), v_a), v_b),smt_minus(v_c, v_d)),smt_ratnum(0)))...

I like it, but I feel bad that I proposed a more complicated way earlier.

While I'm happy translating user defined functions to lambda expressions, I would want to be more cautious about supporting lambda or let expressions in the claim.  The tricky issue here is variable binding.  There are subtle things one do if the same name is used in different scopes.  For example ((lambda (x) ((lambda (x) (* x x)) (+ x 1))) 2) evaluates to 9, but observe that it has two *different* variables named x.

I'll guess that common-lisp has simple, systematic rules to figure out things like this, but we'd have to check all the details.  Otherwise, our SMT solver could give a different interpretation to a formula than ACL2, and we could prove contradictions.  So, I'd like to avoid supporting let and lambda.

The same danger is lurking with function.  What if I wrote:
  (defun three () 3)
  (defun f (x) (+ x (three)))
  (defthm mrg2
    (implies
      (and (integerp a) (integerp b))
      (implies (< b 0) (let ((three (lambda () b)))(< (f a) a)))))

In ACL2, this is not a theorem.  ACL2 fails complaining that it can't find a suitable induction scheme, but the problem is obvious.  If I replace integerp with rationalp, then ACL2 runs a long time.  To translate this to the SMT solver correctly, the translator must recognize that the function 'three' in (defun f (x) (+ x (three))) is the function that returns 3.  But, if your translator uses the 'three' that returns b, then the resulting claim is always true.

The simple fix for this (for now) is to check when your flattening a function to be sure that all variables that appear in the body of the function are formal parameters of that function.

Summary:
It's OK to flatten a user-defined function (in ACL2) to a raw-lisp lambda expression .  Then translate that to a python lambda expression. I think that's a great idea! I don't think we should support let or lambda in the ACL2 clause that the translator accepts. I think this means that the flattener fails with an error message if it encounters let or lambda.  So, there will be no let or lambda in the input to the flattener even though the flattener will produce lambda expressions in its output.

How's that sound?
--Mark

=========================================================================================

Thanks for the great report on handling lists in your translator.  It
looks good.  For handling other functions (cons, car, cdr, append, etc.)
you might first want to look at:
  http://rise4fun.com/Z3Py/tutorial/advanced
In the section titled "Datatypes", they use lists as an example.  I had
considered using that for your translator, but I don't see a good way
to handle "nth" with their construction, and nth was the function you
needed when you started this example.  You might ask Leo, or Sam may know
someone at Microsoft who is even more into programming language support.

Here's a way you could handle most list operations:
  (cons e x) creates a new z3 Array.  You would need your own data
    structure for lists; so you would know the length of x.  Then,
    create an array that is one larger, and initialize the elements.
    Return the array.
      Of course, this isn't very "efficient" -- it takes O(N^2)
    array element copies to create a list from N cons operations.
    As the ACL2 tutorial points out, clear and simple is often better
    for verification than clever and efficient.  So, don't worry about
    it.  It is likely that z3 will simplify the expressions for you.
  (car x) just becomes (nth 0 x) -- I'm sure you knew that!
  (cdr x) The reverse of cons.  Create a new array, and initialize
    the elements.
  (append x y) Create a new array whose length is the sum of (len x)
    and (len y) and initialize the elements.
  (if p x y)  This gets tricker.  For example, consider:
      (nth i (append (cons a (if p0 (cons b y) nil))
		     w
		     (cons c (if p1 (if p2 u v) w))))
    The "obvious" solution is to lift all (if ...) expressions to the
    top of the expression.  This has a disadvantage that the number
    of branches of the resulting if can be exponential in the number
    of original if statements.  I don't think this will be a big deal.
    Because you don't handle recursive functions, you shouldn't end
    up with huge expansion (in practice).  On the other hand, if you
    later generalize your code to handle recursive functions to a
    specified depths (e.g. k) then you could increase the size of
    the expression by an exponential in k.
      Maybe it's best not to handle if's inside list constructing
    functions (at least not for now).
=======
>>>>>>> ACL22Z3
