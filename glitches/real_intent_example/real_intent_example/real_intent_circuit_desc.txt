The data signals, ‘Data A’ and ‘Data B’, are combined and being transferred between asynchronous clock domains clocked by, respectively, signals ‘Clk1’ and ‘Clk2’. The loading of the data in the receiving clock domain is controlled by a synchronized control signal, ‘CNTL’. The AND gate and the multiplexer (shown in a shaded oval in Figure 1) in the RTL description are replaced with the AND-OR circuit (shown again in a shaded oval, now in Figure 2) in the gate-level netlist by a synthesis tool. The exercise of checking that the two circuits are indeed logically equivalent is left to the reader.

Standard CDC design practices state that the data signal being transferred across clock domains is allowed to glitch as long as there is a provision to block the glitch from propagating to the receiving clock domain. This guideline is followed in the RTL schematic and a synchronized control signal gates the propagation of the data signal via the multiplexer.

However, in the logically equivalent netlist implementation, there is a term (the three-input AND gate at the top of Figure 2) that is not gated by the control signal. Hence, a glitch created in that part of the circuit can be propagated and captured in the receive domain in the next cycle. This violates the multicycle nature of the datapath and causes functional errors as the logic in the receive domain is not expecting the data signal to change.

Traditional verification cannot identify such glitches when they are introduced into a gate-level netlist. Functional pre-synthesis zero-delay simulations do not catch glitch issues and logical equivalency checking will declare the RTL design and the gate-level netlist to be equivalent. Since the number of gate-level simulations run is typically a small subset of the pre-synthesis simulations, it is quite possible that the glitch traversal path does not get sensitized by the input vectors in the gate-level netlist simulations and the glitch continues to lurk undetected.

